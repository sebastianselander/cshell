/* File generated by the BNF Converter (bnfc 2.9.5). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;

/********************   Forward Declarations    ***********************/
struct Expression_;
typedef struct Expression_ *Expression;

struct List_;
typedef struct List_ *List;

struct Bang_;
typedef struct Bang_ *Bang;

struct Subshell_;
typedef struct Subshell_ *Subshell;

struct Args_;
typedef struct Args_ *Args;

struct ListIdent_;
typedef struct ListIdent_ *ListIdent;

/********************   Abstract Syntax Classes    ********************/

struct Expression_
{
  enum { is_ExpressionList } kind;
  union
  {
    struct { List list_; } expressionlist_;
  } u;
};

Expression make_ExpressionList(List p0);

struct List_
{
  enum { is_List1, is_List2, is_List3 } kind;
  union
  {
    struct { Bang bang_; List list_; } list1_;
    struct { Bang bang_; List list_; } list2_;
    struct { Bang bang_; List list_; } list3_;
  } u;
};

List make_List1(Bang p0, List p1);
List make_List2(Bang p0, List p1);
List make_List3(Bang p0, List p1);

struct Bang_
{
  enum { is_Bang1, is_BangSubshell } kind;
  union
  {
    struct { Subshell subshell_; } bang1_;
    struct { Subshell subshell_; } bangsubshell_;
  } u;
};

Bang make_Bang1(Subshell p0);
Bang make_BangSubshell(Subshell p0);

struct Subshell_
{
  enum { is_Subshell1, is_Subshell2 } kind;
  union
  {
    struct { List list_; } subshell1_;
    struct { Args args_; Ident ident_; } subshell2_;
  } u;
};

Subshell make_Subshell1(List p0);
Subshell make_Subshell2(Ident p0, Args p1);

struct Args_
{
  enum { is_Args1, is_Args2 } kind;
  union
  {
    struct { Expression expression_; } args1_;
    struct { ListIdent listident_; } args2_;
  } u;
};

Args make_Args1(Expression p0);
Args make_Args2(ListIdent p0);

struct ListIdent_
{
  Ident ident_;
  ListIdent listident_;
};

ListIdent make_ListIdent(Ident p1, ListIdent p2);

/***************************   Cloning   ******************************/

Expression clone_Expression(Expression p);
List clone_List(List p);
Bang clone_Bang(Bang p);
Subshell clone_Subshell(Subshell p);
Args clone_Args(Args p);
ListIdent clone_ListIdent(ListIdent p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Expression(Expression p);
void free_List(List p);
void free_Bang(Bang p);
void free_Subshell(Subshell p);
void free_Args(Args p);
void free_ListIdent(ListIdent p);


#endif
