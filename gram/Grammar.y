/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the grammar_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE grammar__scan_string(const char *str, yyscan_t scanner);
extern void grammar__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void grammar_lex_destroy(yyscan_t scanner);
extern char* grammar_get_text(yyscan_t scanner);

extern yyscan_t grammar__initialize_lexer(FILE * inp);

/* List reversal functions. */
ListIdent reverseListIdent(ListIdent l)
{
  ListIdent prev = 0;
  ListIdent tmp = 0;
  while (l)
  {
    tmp = l->listident_;
    l->listident_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Expression expression_;
  List list_;
  Bang bang_;
  Subshell subshell_;
  Args args_;
  ListIdent listident_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, grammar_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANG    /* ! */
%token          _SYMB_6  /* $( */
%token          _DAMP    /* && */
%token          _LPAREN  /* ( */
%token          _RPAREN  /* ) */
%token          _SEMI    /* ; */
%token          _DBAR    /* || */
%token<_string> _IDENT_

%type <expression_> Expression
%type <list_> List
%type <bang_> Bang
%type <subshell_> Subshell
%type <args_> Args
%type <listident_> ListIdent

%start Expression

%%

Expression : List { $$ = make_ExpressionList($1); result->expression_ = $$; }
;
List : Bang _SEMI List { $$ = make_List1($1, $3); result->list_ = $$; }
  | Bang _DBAR List { $$ = make_List2($1, $3); result->list_ = $$; }
  | Bang _DAMP List { $$ = make_List3($1, $3); result->list_ = $$; }
;
Bang : _BANG Subshell { $$ = make_Bang1($2); result->bang_ = $$; }
  | Subshell { $$ = make_BangSubshell($1); result->bang_ = $$; }
;
Subshell : _LPAREN List _RPAREN { $$ = make_Subshell1($2); result->subshell_ = $$; }
  | _IDENT_ Args { $$ = make_Subshell2($1, $2); result->subshell_ = $$; }
;
Args : _SYMB_6 Expression _RPAREN { $$ = make_Args1($2); result->args_ = $$; }
  | ListIdent { $$ = make_Args2(reverseListIdent($1)); result->args_ = $$; }
;
ListIdent : /* empty */ { $$ = 0; result->listident_ = $$; }
  | ListIdent _IDENT_ { $$ = make_ListIdent($2, $1); result->listident_ = $$; }
;

%%


/* Entrypoint: parse Expression from file. */
Expression pExpression(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse Expression from string. */
Expression psExpression(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = grammar__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  grammar__delete_buffer(buf, scanner);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expression_;
  }
}

/* Entrypoint: parse List from file. */
List pList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.list_;
  }
}

/* Entrypoint: parse List from string. */
List psList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = grammar__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  grammar__delete_buffer(buf, scanner);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.list_;
  }
}

/* Entrypoint: parse Bang from file. */
Bang pBang(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.bang_;
  }
}

/* Entrypoint: parse Bang from string. */
Bang psBang(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = grammar__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  grammar__delete_buffer(buf, scanner);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.bang_;
  }
}

/* Entrypoint: parse Subshell from file. */
Subshell pSubshell(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.subshell_;
  }
}

/* Entrypoint: parse Subshell from string. */
Subshell psSubshell(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = grammar__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  grammar__delete_buffer(buf, scanner);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.subshell_;
  }
}

/* Entrypoint: parse Args from file. */
Args pArgs(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.args_;
  }
}

/* Entrypoint: parse Args from string. */
Args psArgs(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = grammar__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  grammar__delete_buffer(buf, scanner);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.args_;
  }
}

/* Entrypoint: parse ListIdent from file. */
ListIdent pListIdent(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return reverseListIdent(result.listident_);
  }
}

/* Entrypoint: parse ListIdent from string. */
ListIdent psListIdent(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = grammar__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = grammar__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  grammar__delete_buffer(buf, scanner);
  grammar_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return reverseListIdent(result.listident_);
  }
}



