/* File generated by the BNF Converter (bnfc 2.9.5). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   ExpressionList    ********************/

Expression make_ExpressionList(List p1)
{
    Expression tmp = (Expression) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressionList!\n");
        exit(1);
    }
    tmp->kind = is_ExpressionList;
    tmp->u.expressionlist_.list_ = p1;
    return tmp;
}

/********************   List1    ********************/

List make_List1(Bang p1, List p2)
{
    List tmp = (List) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating List1!\n");
        exit(1);
    }
    tmp->kind = is_List1;
    tmp->u.list1_.bang_ = p1;
    tmp->u.list1_.list_ = p2;
    return tmp;
}

/********************   List2    ********************/

List make_List2(Bang p1, List p2)
{
    List tmp = (List) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating List2!\n");
        exit(1);
    }
    tmp->kind = is_List2;
    tmp->u.list2_.bang_ = p1;
    tmp->u.list2_.list_ = p2;
    return tmp;
}

/********************   List3    ********************/

List make_List3(Bang p1, List p2)
{
    List tmp = (List) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating List3!\n");
        exit(1);
    }
    tmp->kind = is_List3;
    tmp->u.list3_.bang_ = p1;
    tmp->u.list3_.list_ = p2;
    return tmp;
}

/********************   Bang1    ********************/

Bang make_Bang1(Subshell p1)
{
    Bang tmp = (Bang) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Bang1!\n");
        exit(1);
    }
    tmp->kind = is_Bang1;
    tmp->u.bang1_.subshell_ = p1;
    return tmp;
}

/********************   BangSubshell    ********************/

Bang make_BangSubshell(Subshell p1)
{
    Bang tmp = (Bang) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BangSubshell!\n");
        exit(1);
    }
    tmp->kind = is_BangSubshell;
    tmp->u.bangsubshell_.subshell_ = p1;
    return tmp;
}

/********************   Subshell1    ********************/

Subshell make_Subshell1(List p1)
{
    Subshell tmp = (Subshell) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Subshell1!\n");
        exit(1);
    }
    tmp->kind = is_Subshell1;
    tmp->u.subshell1_.list_ = p1;
    return tmp;
}

/********************   Subshell2    ********************/

Subshell make_Subshell2(Ident p1, Args p2)
{
    Subshell tmp = (Subshell) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Subshell2!\n");
        exit(1);
    }
    tmp->kind = is_Subshell2;
    tmp->u.subshell2_.ident_ = p1;
    tmp->u.subshell2_.args_ = p2;
    return tmp;
}

/********************   Args1    ********************/

Args make_Args1(Expression p1)
{
    Args tmp = (Args) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Args1!\n");
        exit(1);
    }
    tmp->kind = is_Args1;
    tmp->u.args1_.expression_ = p1;
    return tmp;
}

/********************   Args2    ********************/

Args make_Args2(ListIdent p1)
{
    Args tmp = (Args) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Args2!\n");
        exit(1);
    }
    tmp->kind = is_Args2;
    tmp->u.args2_.listident_ = p1;
    return tmp;
}

/********************   ListIdent    ********************/

ListIdent make_ListIdent(Ident p1, ListIdent p2)
{
    ListIdent tmp = (ListIdent) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListIdent!\n");
        exit(1);
    }
    tmp->ident_ = p1;
    tmp->listident_ = p2;
    return tmp;
}

/***************************   Cloning   ******************************/

Expression clone_Expression(Expression p)
{
  switch(p->kind)
  {
  case is_ExpressionList:
    return make_ExpressionList (clone_List(p->u.expressionlist_.list_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Expression!\n");
    exit(1);
  }
}

List clone_List(List p)
{
  switch(p->kind)
  {
  case is_List1:
    return make_List1
      ( clone_Bang(p->u.list1_.bang_)
      , clone_List(p->u.list1_.list_)
      );

  case is_List2:
    return make_List2
      ( clone_Bang(p->u.list2_.bang_)
      , clone_List(p->u.list2_.list_)
      );

  case is_List3:
    return make_List3
      ( clone_Bang(p->u.list3_.bang_)
      , clone_List(p->u.list3_.list_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning List!\n");
    exit(1);
  }
}

Bang clone_Bang(Bang p)
{
  switch(p->kind)
  {
  case is_Bang1:
    return make_Bang1 (clone_Subshell(p->u.bang1_.subshell_));

  case is_BangSubshell:
    return make_BangSubshell (clone_Subshell(p->u.bangsubshell_.subshell_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Bang!\n");
    exit(1);
  }
}

Subshell clone_Subshell(Subshell p)
{
  switch(p->kind)
  {
  case is_Subshell1:
    return make_Subshell1 (clone_List(p->u.subshell1_.list_));

  case is_Subshell2:
    return make_Subshell2
      ( strdup(p->u.subshell2_.ident_)
      , clone_Args(p->u.subshell2_.args_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Subshell!\n");
    exit(1);
  }
}

Args clone_Args(Args p)
{
  switch(p->kind)
  {
  case is_Args1:
    return make_Args1 (clone_Expression(p->u.args1_.expression_));

  case is_Args2:
    return make_Args2 (clone_ListIdent(p->u.args2_.listident_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Args!\n");
    exit(1);
  }
}

ListIdent clone_ListIdent(ListIdent listident)
{
  if (listident)
  {
    /* clone of non-empty list */
    return make_ListIdent
      ( strdup(listident->ident_)
      , clone_ListIdent(listident->listident_)
      );
  }
  else return NULL; /* clone of empty list */
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Expression(Expression p)
{
  switch(p->kind)
  {
  case is_ExpressionList:
    free_List(p->u.expressionlist_.list_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Expression!\n");
    exit(1);
  }
  free(p);
}

void free_List(List p)
{
  switch(p->kind)
  {
  case is_List1:
    free_Bang(p->u.list1_.bang_);
    free_List(p->u.list1_.list_);
    break;

  case is_List2:
    free_Bang(p->u.list2_.bang_);
    free_List(p->u.list2_.list_);
    break;

  case is_List3:
    free_Bang(p->u.list3_.bang_);
    free_List(p->u.list3_.list_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing List!\n");
    exit(1);
  }
  free(p);
}

void free_Bang(Bang p)
{
  switch(p->kind)
  {
  case is_Bang1:
    free_Subshell(p->u.bang1_.subshell_);
    break;

  case is_BangSubshell:
    free_Subshell(p->u.bangsubshell_.subshell_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Bang!\n");
    exit(1);
  }
  free(p);
}

void free_Subshell(Subshell p)
{
  switch(p->kind)
  {
  case is_Subshell1:
    free_List(p->u.subshell1_.list_);
    break;

  case is_Subshell2:
    free(p->u.subshell2_.ident_);
    free_Args(p->u.subshell2_.args_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Subshell!\n");
    exit(1);
  }
  free(p);
}

void free_Args(Args p)
{
  switch(p->kind)
  {
  case is_Args1:
    free_Expression(p->u.args1_.expression_);
    break;

  case is_Args2:
    free_ListIdent(p->u.args2_.listident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Args!\n");
    exit(1);
  }
  free(p);
}

void free_ListIdent(ListIdent listident)
{
  if (listident)
  {
    free(listident->ident_);
    free_ListIdent(listident->listident_);
    free(listident);
  }
}

